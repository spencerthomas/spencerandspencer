{"version":3,"file":"accordion.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/accordion!\n *\n * TODO: Animation examples\n *\n * @see Docs     https://reacttraining.com/reach-ui/accordion\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/accordion\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n */\n\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  checkStyles,\n  createNamedContext,\n  forwardRefWithAs,\n  isBoolean,\n  isNumber,\n  makeId,\n  noop,\n  useForkedRef,\n  warning,\n  wrapEvent,\n} from \"@reach/utils\";\nimport {\n  createDescendantContext,\n  Descendant,\n  DescendantProvider,\n  useDescendant,\n  useDescendantKeyDown,\n  useDescendantsInit,\n} from \"@reach/descendants\";\nimport { useId } from \"@reach/auto-id\";\nimport PropTypes from \"prop-types\";\n\nconst AccordionDescendantContext = createDescendantContext<AccordionDescendant>(\n  \"AccordionDescendantContext\"\n);\nconst AccordionContext = createNamedContext<InternalAccordionContextValue>(\n  \"AccordionContext\",\n  {} as InternalAccordionContextValue\n);\nconst AccordionItemContext = createNamedContext<\n  InternalAccordionItemContextValue\n>(\"AccordionItemContext\", {} as InternalAccordionItemContextValue);\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport enum AccordionStates {\n  Open = \"OPEN\",\n  Collapsed = \"COLLAPSED\",\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Accordion\n *\n * The wrapper component for all other accordion components. Each accordion\n * component will consist of accordion items whose buttons are keyboard\n * navigable using arrow keys.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-1\n */\nexport const Accordion = forwardRef<HTMLDivElement, AccordionProps>(\n  function Accordion(\n    {\n      children,\n      defaultIndex,\n      index: controlledIndex,\n      onChange,\n      readOnly = false,\n      collapsible = false,\n      multiple = false,\n      ...props\n    },\n    forwardedRef\n  ) {\n    /*\n     * You shouldn't switch between controlled/uncontrolled. We'll check for a\n     * controlled component and track any changes in a ref to show a warning.\n     */\n    const wasControlled = typeof controlledIndex !== \"undefined\";\n    const { current: isControlled } = useRef(wasControlled);\n\n    const [descendants, setDescendants] = useDescendantsInit<\n      AccordionDescendant\n    >();\n\n    const id = useId(props.id);\n\n    // Define our default starting index\n    const [openPanels, setOpenPanels] = useState<AccordionIndex>(() => {\n      switch (true) {\n        case isControlled:\n          return controlledIndex!;\n\n        // If we have a defaultIndex, we need to do a few checks\n        case defaultIndex != null:\n          /*\n           * If multiple is set to true, we need to make sure the `defaultIndex`\n           * is an array (and vice versa). We'll handle console warnings in\n           * our propTypes, but this will at least keep the component from\n           * blowing up.\n           */\n          if (multiple) {\n            return Array.isArray(defaultIndex) ? defaultIndex : [defaultIndex!];\n          } else {\n            return Array.isArray(defaultIndex)\n              ? defaultIndex[0] ?? 0\n              : defaultIndex!;\n          }\n\n        /*\n         * Collapsible accordions with no defaultIndex will start with all\n         * panels collapsed. Otherwise the first panel will be our default.\n         */\n        case collapsible:\n          return multiple ? [] : -1;\n        default:\n          return multiple ? [0] : 0;\n      }\n    });\n\n    if (__DEV__) {\n      warning(\n        !(!isControlled && wasControlled),\n        \"Accordion is changing from controlled to uncontrolled. Accordion should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Accordion for the lifetime of the component. Check the `index` prop being passed in.\"\n      );\n      warning(\n        !(isControlled && !wasControlled),\n        \"Accordion is changing from uncontrolled to controlled. Accordion should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled Accordion for the lifetime of the component. Check the `index` prop being passed in.\"\n      );\n      warning(\n        !(isControlled && collapsible),\n        \"The `collapsible` prop on Accordion has no effect when the state of the component is controlled.\"\n      );\n      warning(\n        !(isControlled && multiple),\n        \"The `multiple` prop on Accordion has no effect when the state of the component is controlled.\"\n      );\n    }\n\n    const onSelectPanel = useCallback(\n      (index: number) => {\n        onChange && onChange(index);\n\n        if (!isControlled) {\n          setOpenPanels((prevOpenPanels) => {\n            /*\n             * If we're dealing with an uncontrolled component, the index arg\n             * in selectChange will always be a number rather than an array.\n             */\n            index = index as number;\n            // multiple allowed\n            if (multiple) {\n              // state will always be an array here\n              prevOpenPanels = prevOpenPanels as number[];\n              if (\n                // User is clicking on an already-open button\n                prevOpenPanels.includes(index as number)\n              ) {\n                // Other panels are open OR accordion is allowed to collapse\n                if (prevOpenPanels.length > 1 || collapsible) {\n                  // Close the panel by filtering it from the array\n                  return prevOpenPanels.filter((i) => i !== index);\n                }\n              } else {\n                // Open the panel by adding it to the array.\n                return [...prevOpenPanels, index].sort();\n              }\n            } else {\n              prevOpenPanels = prevOpenPanels as number;\n              return prevOpenPanels === index && collapsible ? -1 : index;\n            }\n            return prevOpenPanels;\n          });\n        }\n      },\n      [collapsible, isControlled, multiple, onChange]\n    );\n\n    const context: InternalAccordionContextValue = useMemo(\n      () => ({\n        accordionId: id,\n        openPanels: isControlled ? controlledIndex! : openPanels,\n        onSelectPanel: readOnly ? noop : onSelectPanel,\n        readOnly,\n      }),\n      [openPanels, controlledIndex, id, isControlled, onSelectPanel, readOnly]\n    );\n\n    useEffect(() => checkStyles(\"accordion\"), []);\n\n    return (\n      <DescendantProvider\n        context={AccordionDescendantContext}\n        items={descendants}\n        set={setDescendants}\n      >\n        <AccordionContext.Provider value={context}>\n          <div {...props} ref={forwardedRef} data-reach-accordion=\"\">\n            {children}\n          </div>\n        </AccordionContext.Provider>\n      </DescendantProvider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-props\n */\nexport type AccordionProps = Omit<\n  React.HTMLProps<HTMLDivElement>,\n  \"onChange\"\n> & {\n  /**\n   * `Accordion` can accept `AccordionItem` components as children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-children\n   */\n  children: React.ReactNode;\n  /**\n   * Whether or not all panels of an uncontrolled accordion can be toggled\n   * to a closed state. By default, an uncontrolled accordion will have an open\n   * panel at all times, meaning a panel can only be closed if the user opens\n   * another panel. This prop allows the user to collapse all open panels.\n   *\n   * It's important to note that this prop has no impact on controlled\n   * components, since the state of any given accordion panel is managed solely\n   * by the index prop.\n   */\n  collapsible?: boolean;\n  /**\n   * A default value for the open panel's index or indices in an uncontrolled\n   * accordion component when it is initially rendered.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-defaultindex\n   */\n  defaultIndex?: AccordionIndex;\n  /**\n   * The index or array of indices for open accordion panels. The `index` props\n   * should be used along with `onChange` to create controlled accordion\n   * components.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-index\n   */\n  index?: AccordionIndex;\n  /**\n   * The callback that is fired when an accordion item's open state is changed.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-onchange\n   */\n  onChange?(index?: number): void;\n  /**\n   * Whether or not an uncontrolled accordion is read-only or controllable by a\n   * user interaction.\n   *\n   * Generally speaking you probably want to avoid this, as\n   * it can be confusing especially when navigating by keyboard. However, this\n   * may be useful if you want to lock an accordion under certain conditions\n   * (perhaps user authentication is required to access the content). In these\n   * instances, you may want to include an alert when a user tries to activate\n   * a read-only accordion panel to let them know why it does not toggle as may\n   * be expected.\n   *\n   * TODO: Create example with @reach/alert.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-onchange\n   */\n  readOnly?: boolean;\n  /**\n   * Whether or not multiple panels in an uncontrolled accordion can be opened\n   * at the same time. By default, when a user opens a new panel, the previously\n   * opened panel will close. This prop prevents that behavior.\n   *\n   * It's important to note that this prop has no impact on controlled\n   * components, since the state of any given accordion panel is managed solely\n   * by the index prop.\n   */\n  multiple?: boolean;\n};\n\nif (__DEV__) {\n  Accordion.displayName = \"Accordion\";\n  Accordion.propTypes = {\n    children: PropTypes.node.isRequired,\n    defaultIndex: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number),\n    ]) as any,\n    index: (props, name, compName, location, propName) => {\n      let val = props[name];\n      if (props[name] != null && props.onChange == null && !props.readOnly) {\n        return new Error(\n          \"You provided an `index` prop to `Accordion` without an `onChange` handler. This will render a read-only accordion element. If the accordion should be functional, remove the `index` value to render an uncontrolled accordion or set an `onChange` handler to set an index when a change occurs. If the accordion is intended to have a fixed state, use the `readOnly` prop with a `defaultIndex` instead of an `index`.\"\n        );\n      }\n      if (props[name] != null && props.defaultIndex != null) {\n        return new Error(\n          \"You provided an `index` prop as well as a `defaultIndex` prop to `Accordion`. If you want a controlled component, use the index prop with an onChange handler. If you want an uncontrolled component, remove the index prop and use `defaultIndex` instead.\"\n        );\n      }\n      if (Array.isArray(props[name])) {\n        return props[name].some((i: any) => !isNumber(i))\n          ? new Error(\n              \"You provided an array as an index in `Accordion` but one or more of the values are not numeric. Please check to make sure all indices are valid numbers.\"\n            )\n          : null;\n      } else if (props[name] != null && !isNumber(props[name])) {\n        return new Error(\n          `Invalid prop \"${propName}\" supplied to \"${compName}\". Expected \"number\", received \"${\n            Array.isArray(val) ? \"array\" : typeof val\n          }\".`\n        );\n      }\n      return null;\n    },\n    multiple: (props, name, compName, location, propName) => {\n      if (!props[name] && Array.isArray(props.defaultIndex)) {\n        return new Error(\n          `The \"${propName}\" prop supplied to \"${compName}\" is not set or set to \"false\", but an array of indices was provided to the \"defaultIndex\" prop. \"${compName}\" can only have more than one default index if the \"${propName}\" prop is set to \"true\".`\n        );\n      } else if (props[name] != null && !isBoolean(props[name])) {\n        return new Error(\n          `Invalid prop \"${propName}\" supplied to \"${compName}\". Expected \"boolean\", received \"${\n            Array.isArray(props[name]) ? \"array\" : typeof props[name]\n          }\".`\n        );\n      }\n      return null;\n    },\n    onChange: PropTypes.func,\n    readOnly: PropTypes.bool,\n    collapsible: PropTypes.bool,\n  };\n}\n\n/**\n * AccordionItem\n *\n * A group that wraps a an accordion's button and panel components.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem\n */\nexport const AccordionItem = forwardRefWithAs<AccordionItemProps, \"div\">(\n  function AccordionItem(\n    { as: Comp = \"div\", children, disabled = false, ...props },\n    forwardedRef\n  ) {\n    const { accordionId, openPanels, readOnly } = useContext(AccordionContext);\n    const buttonRef: ButtonRef = useRef(null);\n\n    const index = useDescendant(\n      {\n        element: buttonRef.current,\n        disabled,\n      },\n      AccordionDescendantContext\n    );\n\n    // We need unique IDs for the panel and button to point to one another\n    const itemId = makeId(accordionId, index);\n    const panelId = makeId(\"panel\", itemId);\n    const buttonId = makeId(\"button\", itemId);\n\n    const state =\n      (Array.isArray(openPanels)\n        ? openPanels.includes(index) && AccordionStates.Open\n        : openPanels === index && AccordionStates.Open) ||\n      AccordionStates.Collapsed;\n\n    const context: InternalAccordionItemContextValue = {\n      disabled,\n      buttonId,\n      index,\n      itemId,\n      buttonRef,\n      panelId,\n      state,\n    };\n\n    return (\n      <AccordionItemContext.Provider value={context}>\n        <Comp\n          {...props}\n          ref={forwardedRef}\n          data-reach-accordion-item=\"\"\n          data-state={getDataState(state)}\n          data-disabled={disabled ? \"\" : undefined}\n          data-read-only={readOnly ? \"\" : undefined}\n        >\n          {children}\n        </Comp>\n      </AccordionItemContext.Provider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem-props\n */\nexport type AccordionItemProps = {\n  /**\n   * An `AccordionItem` expects to receive an `AccordionButton` and\n   * `AccordionPanel` components as its children, though you can also nest other\n   * components within an `AccordionItem` if you want some persistant content\n   * that is relevant to the section but not collapsible when the\n   * `AccordionButton` is toggled.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem-children\n   */\n  children: React.ReactNode;\n  /**\n   * Whether or not an accordion panel is disabled from user interaction.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem-disabled\n   */\n  disabled?: boolean;\n};\n\nif (__DEV__) {\n  AccordionItem.displayName = \"AccordionItem\";\n  AccordionItem.propTypes = {\n    disabled: PropTypes.bool,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * AccordionButton\n *\n * The trigger button a user clicks to interact with an accordion.\n *\n * Must be a direct child of a `AccordionItem`.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionbutton\n */\nexport const AccordionButton = forwardRefWithAs<AccordionButtonProps, \"button\">(\n  function AccordionButton(\n    {\n      as: Comp = \"button\",\n      children,\n      onClick,\n      onKeyDown,\n      onMouseDown,\n      onPointerDown,\n      tabIndex,\n      ...props\n    },\n    forwardedRef\n  ) {\n    let { onSelectPanel } = useContext(AccordionContext);\n\n    let {\n      disabled,\n      buttonId,\n      buttonRef: ownRef,\n      index,\n      panelId,\n      state,\n    } = useContext(AccordionItemContext);\n\n    let ref = useForkedRef(forwardedRef, ownRef);\n\n    function handleClick(event: React.MouseEvent) {\n      event.preventDefault();\n      if (disabled) {\n        return;\n      }\n      ownRef.current.focus();\n      onSelectPanel(index);\n    }\n\n    let handleKeyDown = useDescendantKeyDown(AccordionDescendantContext, {\n      currentIndex: index,\n      orientation: \"vertical\",\n      key: \"element\",\n      rotate: true,\n      callback(element: HTMLElement) {\n        element && element.focus();\n      },\n      filter: (button) => !button.disabled,\n    });\n\n    return (\n      <Comp\n        // Each accordion header `button` is wrapped in an element with role\n        // `heading` that has a value set for `aria-level` that is appropriate\n        // for the information architecture of the page.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n        // I believe this should be left for apps to handle, since headings\n        // are necessarily context-aware. An app can wrap a button inside any\n        // arbitrary tag(s).\n        // TODO: Revisit documentation and examples\n        // @example\n        // <div>\n        //   <h3>\n        //     <AccordionButton>Click Me</AccordionButton>\n        //   </h3>\n        //   <SomeComponent />\n        // </div>\n\n        // The title of each accordion header is contained in an element with\n        // role `button`. We use an HTML button by default, so we can omit\n        // this attribute.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n        // role=\"button\"\n\n        // The accordion header `button` element has `aria-controls` set to the\n        // ID of the element containing the accordion panel content.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n        aria-controls={panelId}\n        // If the accordion panel associated with an accordion header is\n        // visible, the header `button` element has `aria-expanded` set to\n        // `true`. If the panel is not visible, `aria-expanded` is set to\n        // `false`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n        aria-expanded={state === AccordionStates.Open}\n        tabIndex={disabled ? -1 : tabIndex}\n        {...props}\n        ref={ref}\n        data-reach-accordion-button=\"\"\n        // If the accordion panel associated with an accordion header is\n        // visible, and if the accordion does not permit the panel to be\n        // collapsed, the header `button` element has `aria-disabled` set to\n        // `true`. We can use `disabled` since we opt for an HTML5 `button`\n        // element.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n        disabled={disabled || undefined}\n        id={buttonId}\n        onClick={wrapEvent(onClick, handleClick)}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionbutton-props\n */\nexport type AccordionButtonProps = {\n  /**\n   * Typically a text string that serves as a label for the accordion, though\n   * nested DOM nodes can be passed as well so long as they are valid children\n   * of interactive elements.\n   *\n   * @see https://github.com/w3c/html-aria/issues/54\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionbutton-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  AccordionButton.displayName = \"AccordionButton\";\n  AccordionButton.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * AccordionPanel\n *\n * The collapsible panel in which inner content for an accordion item is\n * rendered.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionpanel\n */\nexport const AccordionPanel = forwardRefWithAs<AccordionPanelProps, \"div\">(\n  function AccordionPanel(\n    { as: Comp = \"div\", children, ...props },\n    forwardedRef\n  ) {\n    const { disabled, panelId, buttonId, state } = useContext(\n      AccordionItemContext\n    );\n\n    return (\n      <Comp\n        hidden={state !== AccordionStates.Open}\n        // Optionally, each element that serves as a container for panel content\n        // has role `region` and `aria-labelledby` with a value that refers to\n        // the button that controls display of the panel.\n        // Role `region` is especially helpful to the perception of structure by\n        // screen reader users when panels contain heading elements or a nested\n        // accordion.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#accordion\n\n        // Avoid using the region role in circumstances that create landmark\n        // region proliferation, e.g., in an accordion that contains more than\n        // approximately 6 panels that can be expanded at the same time.\n        // A user can override this with `role=\"none\"` or `role=\"presentation\"`\n        // TODO: Add to docs\n        role=\"region\"\n        aria-labelledby={buttonId}\n        {...props}\n        ref={forwardedRef}\n        data-reach-accordion-panel=\"\"\n        data-disabled={disabled || undefined}\n        data-state={getDataState(state)}\n        id={panelId}\n        tabIndex={-1}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionpanel-props\n */\nexport type AccordionPanelProps = {\n  /**\n   * Inner collapsible content for the accordion item.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionpanel-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  AccordionPanel.displayName = \"AccordionPanel\";\n  AccordionPanel.propTypes = {\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Accordion` component to its\n * descendants.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#useaccordioncontext\n */\nexport function useAccordionContext(): AccordionContextValue {\n  let { openPanels, accordionId } = useContext(AccordionContext);\n  return useMemo(\n    () => ({\n      id: accordionId,\n      openPanels: ([] as number[])\n        .concat(openPanels as any)\n        .filter((i) => i < 0),\n    }),\n    [accordionId, openPanels]\n  );\n}\n\n/**\n * A hook that exposes data for a given `AccordionItem` component to its\n * descendants.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#useaccordionitemcontext\n */\nexport function useAccordionItemContext(): AccordionItemContextValue {\n  let { index, state } = useContext(AccordionItemContext);\n  return useMemo(\n    () => ({\n      index,\n      isExpanded: state === AccordionStates.Open,\n    }),\n    [index, state]\n  );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction getDataState(state: AccordionStates) {\n  return state === AccordionStates.Open ? \"open\" : \"collapsed\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\nexport type AccordionContextValue = {\n  id: string | undefined;\n  openPanels: number[];\n};\n\nexport type AccordionItemContextValue = {\n  index: number;\n  isExpanded: boolean;\n};\n\ntype AccordionDescendant = Descendant & {\n  disabled: boolean;\n};\n\ntype ResultBox<T> = { v: T };\n\ntype ButtonRef = React.MutableRefObject<any>;\n\ntype AccordionIndex = number | number[];\n\ninterface InternalAccordionContextValue {\n  accordionId: string | undefined;\n  openPanels: AccordionIndex;\n  onSelectPanel(index: AccordionIndex): void;\n  readOnly: boolean;\n}\n\ninterface InternalAccordionItemContextValue {\n  disabled: boolean;\n  buttonId: string;\n  index: number;\n  itemId: string;\n  buttonRef: ButtonRef;\n  panelId: string;\n  state: AccordionStates;\n}\n"],"names":["AccordionStates","AccordionDescendantContext","createDescendantContext","AccordionContext","createNamedContext","AccordionItemContext","Accordion","forwardRef","forwardedRef","children","defaultIndex","controlledIndex","index","onChange","readOnly","collapsible","multiple","props","isControlled","useRef","current","useDescendantsInit","descendants","setDescendants","id","useId","useState","Array","isArray","openPanels","setOpenPanels","onSelectPanel","useCallback","prevOpenPanels","includes","length","filter","i","sort","context","useMemo","accordionId","noop","useEffect","checkStyles","React","DescendantProvider","items","set","Provider","value","ref","AccordionItem","forwardRefWithAs","as","Comp","disabled","useContext","buttonRef","useDescendant","element","itemId","makeId","panelId","buttonId","state","Open","Collapsed","getDataState","undefined","AccordionButton","onClick","onKeyDown","tabIndex","ownRef","useForkedRef","handleKeyDown","useDescendantKeyDown","currentIndex","orientation","key","rotate","callback","focus","button","wrapEvent","event","preventDefault","AccordionPanel","hidden","role","concat","isExpanded"],"mappings":"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"}